(require "cffi")
(pushnew (truename ".") cffi:*foreign-library-directories*)
(require "cl-charms")

(defvar *version* (write-to-string (get-universal-time)))

(defparameter *height* 10)
(defparameter *width* 10)
(defvar *fps* 0)
(defvar *frames* 0)
(defvar *entities* (make-hash-table :test #'equal))
(defparameter *message-line* 14)
(defvar *message-history* ())
(defparameter last-key #\Null)
(defparameter *quit* nil)
(defun gen-level (&optional (level 1))
	(if level
		(let ((world nil))
			(loop for x to *height*
				do (loop for y to *width*
					do (setq world (acons (cons x y) 'floor world))))
			(setq world
				(acons (cons (random *height*)
					   (random *width*))
					   'down
					   world))
			(setq world
				(acons (cons (random *height*)
					   (random *width*))
					   'up
					   world)))))
(defparameter *world* (make-hash-table :test #'equal))
(setf (gethash 1 *world*) (gen-level 1))
(defun getlevel (level)
	(gethash level *world*))
(defun (setf getlevel) (new-value level)
	(setf (gethash level *world*) new-value))
(defparameter *dlvl* 1)
(defparameter *level* (getlevel *dlvl*))
(defstruct entity
  (hp 10)
  (name "Casimir")
  (x nil)
  (y nil)
  (type 'mob)
  (strength 10)
  (dexterity 10)
  (consitution 10)
  (intelligence 10)
  (wisdom 10)
  (charisma 10)
  (luck 10)
  (easter-egg -10)
  (magic 0))
(defmacro set-entity-val (entity val new-value)
	`(setf (,(intern (concatenate 'string "ENTITY-" (string val))) (get-entity ,entity)) ,new-value))
(defun (setf get-entity) (new-value entity)
	(setf (gethash entity *entities*) new-value))
(defun get-entity (entity)
	(gethash entity *entities*))
(defun get-coord (entity)
  `(,(entity-x (get-entity entity)) . ,(entity-y (get-entity entity))))
(defun register-entity (entity &rest keywords)
  (setf (get-entity entity) (apply #'make-entity keywords)))
(defun get-entity-val (entity val)
  (funcall (intern (concatenate 'string "ENTITY-" (string val))) (get-entity entity)))
(defun entity-gen () nil)
(defun player-gen (&key (name "Casimir") (hp 20) (magic 16)
		(type 'player) (y (random *height*)) (x (random *width*)))
	(make-entity :hp hp :magic magic :type type :x x :y y :name name))
(defun create-stock-entities ()
  (register-entity 'player :name "The Choosen One" :x (random *width*) :y (random *height*))
  (register-entity 'mob :name "The Mob One" :x (random *width*) :y (random *height*)))
(defun draw-map (y1 x1)
  (loop for y to *height* and y-curs from y1 to (+ *height* y1 -1)
	do (loop for x to *width* and x-curs from x1 to (+ *width* x1 -1)
		do (charms:move y-curs x-curs)
		(charms:printw (string
				(cond ((equal `(,x . ,y) (get-coord 'player)) #\@)
					((equal `(,x . ,y) (get-coord 'mob)) #\M)
					((equal (cdr (assoc (cons x y) *level* :test #'equal)) 'up) #\<)
					((equal (cdr (assoc (cons x y) *level* :test #'equal)) 'down) #\>)
					((equal (cdr (assoc `(,x . ,y) *level* :test #'equal)) 'floor)  #\.)
					(t #\Space)))))))
(defun entity-distance (ent-1 ent-2)
	(let ((ent-1-x (entity-x (get-entity ent-1)))
			(ent-1-y (entity-y (get-entity ent-1)))
			(ent-2-x (entity-x (get-entity ent-2)))
			(ent-2-y (entity-y (get-entity ent-2))))
		(sqrt (+ (expt (- ent-2-x ent-1-x) 2) (expt (- ent-2-y ent-1-y) 2)))))
(defun attack (attacker attackee)
	(if (<= (entity-distance attacker attackee) 1)
		(progn
			(decf (entity-hp (get-entity attackee)))
			(push
				(format nil "You deal 1 damage to ~d" (entity-name (get-entity attackee)))
				*message-history*))
		(push "You are too far away" *message-history*)))
(defun set-coord (entity coord)
  (setf (entity-x (get-entity entity)) (car coord))
  (setf (entity-y (get-entity entity)) (cdr coord)))
(defun set-coord-relative (entity dir &optional (x 1))
  (case dir 
	(up (decf (entity-y (get-entity entity)) x))
	(down (incf (entity-y (get-entity entity)) x))
	(left (decf (entity-x (get-entity entity)) x))
	(right (incf (entity-x (get-entity entity)) x)))
  (setf (entity-x (get-entity entity)) (mod (entity-x (get-entity entity)) *width*))
  (setf (entity-y (get-entity entity)) (mod (entity-y (get-entity entity)) *height*)))
(defun walk (entity dir)
	(set-coord-relative entity dir))
#|(defmacro some-macro (prefix &rest endings)
	(loop for x in endings
		  collect ()))|#
;(defun set-entity-val (entity val new-value)
;	`(setf (,(intern (concatenate 'string "ENTITY-" (string val))) (get-entity ,entity)) ,new-value))
(defun print-message-history (message-history row)
	(if (not (< row 0))
		(let* ((msg1 (car message-history)) (msg2 (if msg1 msg1 " ")))
			(charms:move row 20)
			(charms:printw (string (format nil "~d" msg2)))
			(charms:clrtoeol)
			(print-message-history (cdr message-history) (1- row)))))
(defun get-tile (coord)
	(cdr (assoc coord *level* :test #'equal)))
(defun on-tile-p (entity tile)
	(let ((coord (get-coord entity)))
		(equal tile (get-tile coord))))
(defmacro with-curses (&body body)
	`(unwind-protect
		(progn
			(charms:initscr)
			,@body)
		(charms:endwin)))
(defun main ()
	(create-stock-entities)
	(with-curses
		(charms:raw)
		(charms:noecho)
		(charms:nodelay charms:*stdscr* 1)
		(charms:keypad charms:*stdscr* 1)
		(charms:erase)
		(loop with time = (get-universal-time)
			do (if (equal (get-universal-time) time)
				   (incf *frames*)
				   (progn
						;(charms:move 1 0)
						;(charms:printw (string (car *messages*)))
						;(pop *messages*)
						(setf *fps* *frames* *frames* 0)
						(setf time (get-universal-time))))
			(game)
			(charms:refresh)
			(if *quit* (return)))
		(setf *quit* nil)))
(defun game ()
	(sleep 1/31)
	(charms:move 0 0)
	(charms:printw (format nil "FPS: ~d     " *fps*))
	(draw-map 3 0)
	(charms:move (+ *height* 4) 0)
	(charms:move 16 0)
	(charms:printw (format nil "Last key: ~c" last-key))
	(charms:move 1 0)
	(charms:printw
		(format nil "Distance: ~$  " (entity-distance 'player 'mob)))
	(charms:move (+ *height* 1 3) 0) (charms:printw (format nil "Dlvl: ~a" *dlvl*))
	(print-message-history *message-history* *message-line*)
	(let* ((input (charms:wgetch charms:*stdscr*))
		(cmd (if (eq input -1) #\Null (code-char input))))
	(if (equal cmd #\Null) nil (setf last-key cmd))
	(case cmd
		((#\4 #\h) (walk 'player 'left))
		((#\2 #\j) (walk 'player 'down))
		((#\8 #\k) (walk 'player 'up))
		((#\6 #\l) (walk 'player 'right))
		(#\a (attack 'player 'mob))
		(#\> (push "Downing" *message-history*)
			(cond ((on-tile-p 'player 'down)
				(incf *dlvl*)
				(if (getlevel *dlvl*)
					nil
					(setf (getlevel *dlvl*) (gen-level)))
				(setf *level* (getlevel *dlvl*)))))
		(#\< (push "Uping" *message-history*)
			(cond ((on-tile-p 'player 'up)
				(if (eq *dlvl* 1)
					(push "Can't exit the dungeon!" *message-history*)
					(progn
						(decf *dlvl*)
						(if (getlevel *dlvl*)
							nil
							(setf (getlevel *dlvl*) (gen-level)))
						(setf *level* (getlevel *dlvl*)))))))
		(#\q (setf *quit* t))
		(#\Null ())
		(otherwise (push (format nil "~a is not bound." cmd) *message-history*)))))
(defun curses ()
	(charms:initscr)
	(charms:erase)
	(charms:raw)
	(charms:keypad charms:*stdscr* 1)
	(charms:noecho)
	(charms:move 0 0)
	(charms:printw (charms:getch))
	(charms:move 0 0)
	(charms:refresh)
	(sleep 3)
	(charms:endwin))
(defun fps ()
	(with-curses
		(charms:erase)
		(charms:refresh)
		(loop with time = (get-universal-time)
			do (if (equal (get-universal-time) time)
				   (incf *frames*)
				   (progn
						;(charms:move 1 0)
						;(charms:printw (string (car *messages*)))
						;(pop *messages*)
						(setf *fps* *frames* *frames* 0)
						(setf time (get-universal-time))))
			(charms:move 0 0)
			(if *quit* (return))
			(charms:printw (format nil "FPS: ~d" *fps*))
			(charms:refresh))))
