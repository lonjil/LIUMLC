(ql:quickload "cffi")
(pushnew (truename ".") cffi:*foreign-library-directories*)
;(ql:quickload "cl-charms")
(load #P"charms\\package.lisp")
(load #P"charms\\charms.lisp")

(defparameter *height* 10)
(defparameter *width* 10)
(defparameter *entities* nil)
(setq *world* (progn
		(let ((world nil))
		  (loop for x to *height*
			do (loop for y to *width*
				 do (setq world (acons (cons x y) 'floor world))))
		  world)))
(defstruct entity
  (hp 10)
  (name "Casimir")
  (x nil)
  (y nil)
  (type 'mob)
  (strength 10)
  (dexterity 10)
  (consitution 10)
  (intelligence 10)
  (wisdom 10)
  (charisma 10)
  (luck 10)
  (easter-egg -10)
  (magic 0))
(defun register-entity (entity &rest keywords)
  (setf *entities* (acons entity (apply #'make-entity keywords) *entities*)))
(defun get-entity-val (entity val)
  (funcall (intern (concatenate 'string "ENTITY-" (string val))) (get-entity entity)))
(defun entity-gen () nil)
(defun player-gen (&key (name "Casimir") (hp 20) (magic 16)
		(type 'player) (y (random *height*)) (x (random *width*)))
	(make-entity :hp hp :magic magic :type type :x x :y y :name name))
(defun create-stock-entities ()
  (register-entity 'player :name "The Choosen One" :x (random *width*) :y (random *height*))
  (register-entity 'mob :name "The Mob One" :x (random *width*) :y (random *height*)))
(defun draw-map (y1 x1)
  (loop for y to *height* and y-curs from y1 to (+ *height* y1)
	do (loop for x to *width* and x-curs from x1 to (+ *width* x1)
		do (charms:move y-curs x-curs)
		(charms:printw (string
				(cond ((equal `(,x . ,y) (get-coord 'player)) #\@)
					((equal `(,x . ,y) (get-coord 'mob)) #\M)
					((equal (cdr (assoc `(,x ,y) *world* :test #'equal)) 'floor)  #\.)
					(t #\Space)))))))

(defun get-coord (entity)
  `(,(entity-x (get-entity entity)) . ,(entity-y (get-entity entity))))
(defun set-coord (entity coord)
  (setf (entity-x (get-entity entity)) (car coord))
  (setf (entity-y (get-entity entity)) (cdr coord)))
(defun set-coord-relative (entity dir &optional (x 1))
  (case dir 
	('up (decf (entity-y (get-entity entity)) x))
	('down (incf (entity-y (get-entity entity)) x))
	('left (decf (entity-x (get-entity entity)) x))
	('right (incf (entity-x (get-entity entity)) x))))
;(defun walk (entity dir &optional (x 1))
;  (cond ((<= (entity-dexterity (get-entity entity)) x)
;	 (set-coord-relative (get-entity entity) dir x))))
(defun walk (entity dir)
	(set-coord-relative (get-entity entity)))
(defun get-entity (entity)
	(cdr (assoc entity *entities* :test #'equal)))
(defun main ()
	(create-stock-entities)
	(setf *yoyo* "")
	(charms:initscr)
	(charms:erase)
	(loop
		(charms:refresh)
		(sleep 1/20)
		(draw-map 3 0)
		(charms:move (+ *height* 4) 0)
		(let ((cmd (code-char (charms:wgetch charms:*stdscr*))))
			(cond ((equal cmd #\w) (walk 'player 'up))
				((equal cmd #\a) (walk 'player 'left))
				((equal cmd #\s) (walk 'player 'down))
				((equal cmd #\d) (walk 'player 'right))
				((equal cmd #\q) (return))
				(t (charms:move 2 0) (charms:printw (string cmd))))))
	(charms:endwin))
(defun curses ()
	(charms:initscr)
	(charms:raw)
	(charms:keypad charms:*stdscr* 1)
	(charms:noecho)
	(setf out (string (code-char (charms:wgetch charms:*stdscr*))))
	(charms:printw out)
	(charms:refresh)
	(sleep 1)
	(charms:endwin))
